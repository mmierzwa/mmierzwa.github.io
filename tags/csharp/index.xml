<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Csharp on byteloom - Marek Mierzwa</title><link>https://byteloom.marek-mierzwa.com/tags/csharp/</link><description>Recent content in Csharp on byteloom - Marek Mierzwa</description><generator>Hugo</generator><language>en</language><copyright>Copy, _right?_ :thinking_face:</copyright><lastBuildDate>Thu, 18 Aug 2016 18:00:00 +0000</lastBuildDate><atom:link href="https://byteloom.marek-mierzwa.com/tags/csharp/index.xml" rel="self" type="application/rss+xml"/><item><title>Under the hood</title><link>https://byteloom.marek-mierzwa.com/blog/under-the-hood/</link><pubDate>Thu, 18 Aug 2016 18:00:00 +0000</pubDate><guid>https://byteloom.marek-mierzwa.com/blog/under-the-hood/</guid><description>&lt;p>It&amp;rsquo;s always good to have static code analysis in your build process. I guess no one these days argues with this statement. This usually forces developer to make conscious decisions on code-level performance, reliability, security, design etc. Few times CA warnings saved me from producing a quite nasty bugs. Sometimes however FxCop yields some really strange stuff.&lt;br>
This post will describe the one I stuck with some time ago. But more interestingly it shows that sometimes .Net developer must look deep under the hood of high-level language abstraction to solve certain issues.&lt;/p></description></item></channel></rss>