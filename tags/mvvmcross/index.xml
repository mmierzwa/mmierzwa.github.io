<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mvvmcross on byteloom - Marek Mierzwa</title><link>https://byteloom.marek-mierzwa.com/tags/mvvmcross/</link><description>Recent content in Mvvmcross on byteloom - Marek Mierzwa</description><generator>Hugo</generator><language>en</language><copyright>Copy, _right?_ :thinking_face:</copyright><lastBuildDate>Mon, 08 May 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://byteloom.marek-mierzwa.com/tags/mvvmcross/index.xml" rel="self" type="application/rss+xml"/><item><title>How to setup Ninject as the default DI container in MvvmCross?</title><link>https://byteloom.marek-mierzwa.com/blog/how-to-setup-ninject-as-the-default-di-container-in-mvvmcross/</link><pubDate>Mon, 08 May 2017 00:00:00 +0000</pubDate><guid>https://byteloom.marek-mierzwa.com/blog/how-to-setup-ninject-as-the-default-di-container-in-mvvmcross/</guid><description>&lt;p>When you build a multi-platform application in .NET, especially for the mobile, you typically choose between two approaches. One is to code the shared UI layer commonly with Xamarin.Forms (you will still need to have some parts to be placed in platform projects, like custom renderers or providers). The second is to put the entire UI code in platform-specific projects. In this approach you can use the full power of each platform features (like fragments on Android). Both solutions allow for sharing common business logic between all the platforms. On the other hand full implementation of MVVM pattern in the second approach can be tricky and time consuming. The solution is to use 3rd party library; and here comes the MvvmCross. It covers many more areas than the pure MVVM pattern:&lt;/p></description></item><item><title>AppCompat support in MVVMCross Android splash screen</title><link>https://byteloom.marek-mierzwa.com/blog/appcompat-support-in-mvvmcross-android-splash-screen/</link><pubDate>Thu, 20 Apr 2017 00:00:00 +0000</pubDate><guid>https://byteloom.marek-mierzwa.com/blog/appcompat-support-in-mvvmcross-android-splash-screen/</guid><description>&lt;p>As it&amp;rsquo;s mentioned in &lt;a href="https://www.mvvmcross.com/documentation/fundamentals/navigation/navigation.html" target="_blank" rel="noreferrer">MVVMCross documentation&lt;/a> Android is quite specific in terms of navigation requirements. The entry point is statically indicated by &lt;code>MainLauncher = true&lt;/code> attribute parameter on the activity. On rest of the platforms, specifically on iOS, this can be done dynamically by implementing &lt;code>IMvxAppStart&lt;/code> class for registration in &lt;code>MvxApplication.Initialize()&lt;/code>.&lt;/p></description></item><item><title>Why does MVVMCross view model initialize twice on iOS?</title><link>https://byteloom.marek-mierzwa.com/blog/why-mvvmcross-vm-init-twice-on-ios/</link><pubDate>Thu, 16 Mar 2017 18:00:00 +0000</pubDate><guid>https://byteloom.marek-mierzwa.com/blog/why-mvvmcross-vm-init-twice-on-ios/</guid><description>&lt;p>Working on a bug fix in MVVMCross-based mobile application I noticed a strange behavior. The navigation to other view model I put in &lt;code>async Init&amp;lt;TInit&amp;gt;(TInit parameters)&lt;/code> which as executed on the first view model in my app was running twice. After a short debugging session it turned out that &lt;code>MvxViewModel&amp;lt;TInit&amp;gt;&lt;/code> &lt;code>Init()&lt;/code> is called from the view controllers &lt;code>ViewDidLoad()&lt;/code> method. Obviously there was something I was missing in terms of &lt;code>ViewDidLoad()&lt;/code> semantics.&lt;/p></description></item></channel></rss>